<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
  <title>iRRAM : exact real arithmetic</title>
</head>
  <body>
                  
<center>           
<h1><a name="iRRAM_:_exact_real_arithmetic_"></a> iRRAM : exact real arithmetic<br>
        </h1>
        </center>
               
<hr width="100%" size="2"><br>
       <br>
           <font size="-1"> Copyright (C) 2001-2003 Norbert Mueller   <br>
        <br>
         This file is part of the iRRAM Library.   <br>
        <br>
         The iRRAM Library is free software; you can redistribute it and/or 
 modify    it under the terms of the GNU Library General Public License as 
 published   by the Free Software Foundation; either version 2 of the License, 
 or (at  your option) any later version.   The iRRAM Library is distributed 
 in the  hope that it will be useful, but WITHOUT ANY WARRANTY; without even 
 the implied   warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
   See the   GNU Library General Public License for more details.   You should
  have received   a copy of the GNU Library General Public License along
with   the iRRAM Library;   see the file COPYING.LIB.  If not, write to the
Free   Software Foundation,   Inc., 59 Temple Place - Suite 330, Boston,
MA 02111-1307,   USA.  </font>  <br>
        <br>
    
<hr width="100%" size="2"><br>
       <br>
              
<ol>
          <li><a href="#INTRODUCTION">Introduction</a></li>
          <li><a href="#DYADIC">Dyadic numbers</a></li>
          <li><a href="#REAL">Real numbers</a></li>
          <li><a href="#INTEGER">Integers</a></li>
          <li><a href="#RATIONAL">Rational numbers</a></li>
          <li><a href="#COMPLEX">Complex numbers</a></li>
          <li><a href="#INTERVAL">Intervals of real numbers</a></li>
          <li><a href="#REALMATRIX">Matrices of real numbers</a></li>
          <li><a href="#SPARSEREALMATRIX">Sparse matrices of real numbers</a></li>
          <li><a href="#LAZY_BOOLEAN">Lazy booleans</a></li>
          <li><a href="#functions">Implemented arithmetic functions</a></li>
          <li><a href="#limits">Limit operators</a></li>
         <li><a href="#USAGE">Usage models</a></li>
             
</ol>
               
<hr width="100%" size="2"><br>
       <br>
   <a name="INTRODUCTION"></a><b><big>Introduction</big></b><br>
          This file is an initial version of a documentation of the user
interface     to the iRRAM package. It is in an early alpha stage!<br>
       <br>
     
<hr width="100%" size="2"><br>
       <br>
       <a name="USAGE"></a><b><big>Usage models</big></b><br>
The iRRAM can be used in two different modes: <br>
(1) main mode<br>
(2) library mode<br>
<br>
In main mode, &nbsp;the user has to define a function <tt>void compute(void);
</tt>instead of the usual<tt> int main(...)</tt> This function will be then
used as the main routine of the iRRAM. Especially, this function is the anchor
of all iterations necessary to implement the exact real semantics.<br>
<br>
In library mode, &nbsp;the user is able to use the iRRAM as a tool to compute
discrete functions internally using of exact reals. <br>
<br>
                 
<pre>extern "C" void iRRAM_initialize(int argc,char** argv);<br><br>template &lt;class ARGUMENT, class RESULT&gt; <br> RESULT iRRAM_exec (RESULT f(ARGUMENT), ARGUMENT);<br><br>#ifndef do_not_activate_iRRAM_control<br>extern void compute(void); <br><br>long iRRAM_compute(long arg){compute();return 0L;};<br> <br>int main (int argc,char **argv){<br>  iRRAM_initialize(argc,argv);<br>  long erg=iRRAM_exec(iRRAM_compute,0L);<br>}<br>#endif<br><br></pre>
         <a href="#iRRAM_:_exact_real_arithmetic_">Back to top</a><br>
               
<hr width="100%" size="2"><br>
       <br>
       <a name="DYADIC"></a><b><big>Dyadic Numbers</big></b><br>
                 
<pre>/****************************************************************************/<br>// Definition of class DYADIC <br>/****************************************************************************/<br><br>class DYADIC<br>{<br>public:<br><br>// Set absolute precision for operations:  -----<br><br>static void setprec(long p) {precision=p;};<br><br>// Constructors: -------------------------------<br><br>DYADIC ();<br>DYADIC (const long i);<br>DYADIC (const DYADIC&amp; y);<br><br>// Copy Constructor: ---------------------------<br><br><br>DYADIC&amp;   operator = (const DYADIC&amp; y);<br><br>// Destructor: ---------------------------------<br><br>~DYADIC();<br><br>// Standard Arithmetic: ------------------------<br><br>friend DYADIC  operator +  (const DYADIC&amp; x,<br>                            const DYADIC&amp; y);<br><br>friend DYADIC  operator -  (const DYADIC&amp; x,<br>                            const DYADIC&amp; y);<br><br>friend DYADIC  operator -  (const DYADIC&amp; x);<br><br>friend DYADIC  operator *  (const DYADIC&amp; x,<br>                            const DYADIC&amp; y);<br><br>friend DYADIC  operator /  (const DYADIC&amp; x,<br>                            const DYADIC&amp; y);<br><br>// Comparisons: --------------------------------<br><br>friend bool    operator &lt;  (const DYADIC&amp; x,<br>                            const DYADIC&amp; y);<br><br>friend bool    operator &lt;= (const DYADIC&amp; x,<br>                            const DYADIC&amp; y);<br><br>friend bool    operator &gt;  (const DYADIC&amp; x,<br>                            const DYADIC&amp; y);<br><br>friend bool    operator &gt;= (const DYADIC&amp; x,<br>                            const DYADIC&amp; y);<br><br>friend bool    operator == (const DYADIC&amp; x,<br>                            const DYADIC&amp; y);<br><br>friend bool    operator != (const DYADIC&amp; x,<br>                            const DYADIC&amp; y);<br><br>// Output: -------------------------------------<br><br>friend void    rwrite      (const DYADIC&amp; x,<br>                            const long w);<br><br>// miscellaneous: ------------------------------<br><br>friend long    size        (const DYADIC&amp; x); <br><br>friend DYADIC  abs         (const DYADIC&amp; x); <br><br>// coexistence with other classes: -------------<br><br>friend class REAL;<br>friend class INTEGER;<br>friend class RATIONAL;<br><br>friend DYADIC  approx      (const REAL&amp; x, <br>                            const long p);<br><br>DYADIC(const INTEGER&amp; x);<br><br>// implementational issues: --------------------<br><br>MP_type    value; <br><br><br>private:<br><br>static long precision;<br><br><br>DYADIC(MP_type  y);<br><br>};<br></pre>
         <a href="#iRRAM_:_exact_real_arithmetic_">Back  to top</a><br>
        
<hr width="100%" size="2"><br>
       <br>
          <a name="LAZY_BOOLEAN"></a><b><big>Lazy Booleans</big></b><br>
                 
<pre><br>/****************************************************************************/<br>// Definition of class LAZY_BOOLEAN <br>/****************************************************************************/<br>#define BOTTOM -1<br>class LAZY_BOOLEAN<br>{<br>public:<br>LAZY_BOOLEAN(){value=0;};<br>LAZY_BOOLEAN(int b){value=b;};<br>friend LAZY_BOOLEAN operator &amp;&amp; (const LAZY_BOOLEAN&amp; x, const LAZY_BOOLEAN&amp; y);<br>friend LAZY_BOOLEAN operator || (const LAZY_BOOLEAN&amp; x, const LAZY_BOOLEAN&amp; y);<br>friend LAZY_BOOLEAN operator ! ( const LAZY_BOOLEAN&amp; x);<br>friend int choose(const LAZY_BOOLEAN&amp; x1= false,<br>                  const LAZY_BOOLEAN&amp; x2= false,<br>                  const LAZY_BOOLEAN&amp; x3= false,<br>                  const LAZY_BOOLEAN&amp; x4= false,<br>                  const LAZY_BOOLEAN&amp; x5= false,<br>                  const LAZY_BOOLEAN&amp; x6= false );<br>operator bool const ();<br>private:<br>int value;<br>};<br></pre>
         <a href="#iRRAM_:_exact_real_arithmetic_">Back  to top</a><br>
               
               
<hr width="100%" size="2"><br>
       <br>
     <a name="REAL"></a><b><big>Real Numbers</big></b><br>
                 
<pre>/****************************************************************************/<br>// Definition of class REAL <br>/****************************************************************************/<br><br>class REAL<br>{<br>public:<br><br>// Constructors: -------------------------------<br><br>REAL();<br>REAL(int  i);<br>REAL(long i);<br>REAL(char* s);<br>REAL(const DYADIC&amp; y);<br>REAL(const REAL&amp; y);<br>REAL(double d);<br>REAL(const INTEGER&amp; y);<br>REAL(const RATIONAL&amp; y);<br><br>// Copy Constructor: ---------------------------<br><br>REAL&amp; operator = (const REAL&amp; y);<br><br>// Destructor: ---------------------------------<br><br>~REAL();<br><br>// Standard Arithmetic: ------------------------<br><br>friend REAL  operator +  (const REAL&amp; x,	const REAL&amp; y);<br>friend REAL  operator +  (const REAL&amp; x,	long int n);<br>friend REAL  operator +  (long int n,	const REAL&amp; x);<br>friend REAL&amp; operator += (REAL&amp; x,		const REAL&amp; y);<br>			  <br>friend REAL  operator -  (const REAL&amp; x, 	const REAL&amp; y);<br>friend REAL  operator -  (const REAL&amp; x,	long int n);<br>friend REAL  operator -  (long int n,	const REAL&amp; x);<br>friend REAL  operator -  (const REAL&amp; x);<br><br>friend REAL  operator *  (const REAL&amp; x,	const REAL&amp; y);<br>friend REAL  operator *  (const REAL&amp; x, 	long int n);<br>friend REAL  operator *  (long int n, 	const REAL&amp; x);<br>			  <br>friend REAL&amp; operator *= (REAL&amp; x,		const REAL&amp; y);<br>friend REAL&amp; operator *= (REAL&amp; x,		long int n);<br>			  <br>friend REAL  operator /  (const REAL&amp; x,	const REAL&amp; y);<br>friend REAL  operator /  (const REAL&amp; x,	long int n);<br>friend REAL  operator /  (long int n,	const REAL&amp; x);<br><br>friend REAL  operator ^  (const REAL&amp; x,	const REAL&amp; y);<br>friend REAL  operator ^  (const REAL&amp; x,	long n);<br><br>friend REAL  operator &lt;&lt; (const REAL&amp; x,	long n);<br>friend REAL  operator &gt;&gt; (const REAL&amp; x,	long n);<br><br>friend REAL  sqrt        (const REAL&amp; x);<br><br>friend REAL  square      (const REAL&amp; x);<br><br>friend REAL  scale       (const REAL&amp; x,<br>                          long k);<br><br>// Comparisons: --------------------------------<br><br><br>friend LAZY_BOOLEAN  operator &lt;  (const REAL&amp; x, const REAL&amp; y);<br>friend LAZY_BOOLEAN  operator &lt;= (const REAL&amp; x, const REAL&amp; y);<br>friend LAZY_BOOLEAN  operator &gt;  (const REAL&amp; x, const REAL&amp; y);<br>friend LAZY_BOOLEAN  operator &gt;= (const REAL&amp; x, const REAL&amp; y);<br><br>friend LAZY_BOOLEAN  positive    (const REAL&amp; x, const long k);<br><br>friend LAZY_BOOLEAN  bound       (const REAL&amp; x, const long k);<br><br>friend DYADIC approx     (const REAL&amp; x, const long p);<br><br>// Output: -------------------------------------<br><br>friend void   rwrite     (const REAL&amp; x, const long p, const long w);<br>friend char*  swrite     (const REAL&amp; x, const long p, const long w);<br>friend void   rwrite     (const REAL&amp; x, const long w);<br>friend char*  swrite     (const REAL&amp; x, const long w);<br>friend void   rshow      (const REAL&amp; x, const long w);<br><br>void REAL::rcheck() const;<br><br>friend long    upperbound (const REAL&amp; x);<br>friend long    size       (const REAL&amp; x); <br><br><br><br>friend REAL    round2     (const REAL&amp; x); <br>friend long    round      (const REAL&amp; x); <br><br>friend REAL    abs        (const REAL&amp; x);<br> <br><br>// limit operators: ------------------------<br><br>//friend REAL    limit      (REAL f(long, const REAL&amp;),<br>//                           const REAL&amp; x);<br><br>friend REAL    limit      (REAL f(long, const REAL&amp;, const REAL&amp;),<br>                           const REAL&amp; x, <br>                           const REAL&amp; y);<br><br>friend REAL    limit      (REAL f(long));<br><br>friend REAL    limit_hint (REAL f(long, const REAL&amp;),<br>                           long hint,<br>                           const REAL&amp; x);<br><br>friend REAL    limit_hint (REAL f(long, const REAL&amp;, const REAL&amp;),<br>                           long hint,<br>                           const REAL&amp; x, <br>                           const REAL&amp; y);<br><br>friend REAL    limit_hint (REAL f(long),<br>                           long hint);<br><br>friend REAL    limit_lip  (REAL f(long, const REAL&amp;),<br>                           long lip,<br>                           const REAL&amp; x);<br><br>friend REAL    limit_lip   (REAL f(long, const REAL&amp;, const REAL&amp;),<br>                           long lip,<br>                           const REAL&amp; x,<br>                           const REAL&amp; y);<br><br>friend REAL    iterate     (REAL (*)(REAL&amp;, REAL&amp;, const REAL&amp;),<br>                           const REAL&amp;, const REAL&amp;, const REAL&amp;);<br><br>friend REAL    iterate     (REAL (*)(REAL&amp;, REAL&amp;),<br>                           const REAL&amp;, const REAL&amp;);<br><br>// reduced error propagation: ------------------------<br><br>friend REAL    lipschitz  (REAL f(const REAL&amp;),<br>                           long lip,<br>                           const REAL&amp; x);<br><br>friend REAL    lipschitz  (REAL f(const REAL&amp;,const REAL&amp;),<br>                           long lip,<br>                           const REAL&amp; x,<br>                           const REAL&amp; y);<br><br>friend REAL    lipschitz  (REAL f(long, const REAL&amp;),<br>                           long lip,<br>                           long k,<br>                           const REAL&amp; x);<br><br>friend REAL    lipschitz  (REAL f(long, const REAL&amp;,const REAL&amp;),<br>                           long lip,<br>                           long k,<br>                           const REAL&amp; x,<br>                           const REAL&amp; y);<br><br>// coexistence with other classes: -------------<br><br>friend class REALMATRIX;<br>friend class SPARSEREALMATRIX;<br>friend class INTEGER;<br>friend class RATIONAL;<br><br>// implementational issues: --------------------<br><br>private:<br><br>MP_type       value; <br>sizetype      error;<br><br><br>public:<br>REAL(MP_type y, const sizetype errorinfo);<br>void adderror (sizetype error);<br>void seterror (sizetype error);<br>void geterror (sizetype&amp; error) const;<br><br>};<br><br><br>void rscanf  (const char *format, void * input);<br>void rprintf (const char *rformat, ...);<br><br>void continous_begin ();<br>void continous_end   ();<br><br><br>#define iRRAM_ABSOLUTE 0<br>#define iRRAM_RELATIVE 1<br>void precision_policy (long policy);<br><br>void stiff_begin ();<br>void stiff_end   ();<br><br><br>REAL strtoREAL(char* s, char** endptr);<br>REAL atoREAL(char* s);<br></pre>
        <a href="#iRRAM_:_exact_real_arithmetic_">Back  to top</a><br>
               
<hr width="100%" size="2"><br>
       <br>
     <a name="REALMATRIX"></a><b><big>Matrices of real numbers</big></b><br>
                 
<pre>/****************************************************************************/<br>// Definition of class REALMATRIX<br>/****************************************************************************/<br><br>class REALMATRIX<br>{<br>public:<br>// Constructors: -------------------------------<br><br>REALMATRIX(unsigned int rows,unsigned int columns);<br>REALMATRIX();<br>REALMATRIX(const REALMATRIX&amp; y);<br>// Copy Constructor: ---------------------------<br><br>REALMATRIX&amp;   operator = (const REALMATRIX&amp; y);<br><br>// Destructor: ---------------------------------<br><br>~REALMATRIX();<br><br>// Access to matrix elements: ------------------<br><br>REAL&amp;   operator ()           (unsigned int row,<br>                               unsigned int column) const;<br><br>REAL&amp;   element               (unsigned int row,<br>                               unsigned int column) const;<br><br>// Standard Arithmetic: ------------------------<br><br>friend REALMATRIX  operator + (const REALMATRIX&amp; x,<br>                               const REALMATRIX&amp; y);<br>friend REALMATRIX  operator - (const REALMATRIX&amp; x,<br>                               const REALMATRIX&amp; y);<br>friend REALMATRIX  operator * (const REALMATRIX&amp; x,<br>                               const REALMATRIX&amp; y);<br>friend REALMATRIX  operator / (const REALMATRIX&amp; x,<br>                               const REALMATRIX&amp; y);<br><br>// Arithmetic with Scalar: ---------------------<br>friend REALMATRIX  operator * (const REALMATRIX&amp; x,<br>                               const REAL&amp; y);<br>inline friend REALMATRIX operator * (const REAL&amp; y,<br>                               const REALMATRIX&amp; x)<br>       {return x*y;};<br><br>friend REALMATRIX  operator / (const REALMATRIX&amp; x,<br>                               const REAL&amp; y);<br><br>// Information on Dimensions: ------------------<br><br>friend inline unsigned int rows (const REALMATRIX&amp; x)<br>                {return x.maxrow;};<br>friend inline unsigned int columns (const REALMATRIX&amp; x)<br>                {return x.maxcolumn;};<br><br>friend int bound (const REALMATRIX&amp; x, <br>                  const long k);<br><br>// Linear Algebra: -----------------------------<br><br>friend REALMATRIX eye     (unsigned int rows);<br>friend REALMATRIX zeroes  (unsigned int rows,<br>                           unsigned int columns);<br>friend REALMATRIX ones    (unsigned int rows,<br>                           unsigned int columns);<br>friend REAL       maxnorm (const REALMATRIX&amp; x);<br>friend REAL       rowsumnorm (const REALMATRIX&amp; x);<br>friend REAL       colsumnorm (const REALMATRIX&amp; x);<br><br>friend REALMATRIX solve (<br>       REALMATRIX&amp; lside,<br>       REALMATRIX&amp; rside,<br>       int use_pivot);<br><br>// IO-routines: --------------------------<br><br>friend void       rwrite  (const REALMATRIX&amp; x,<br>                           const long p,<br>                           const long w);<br>friend void       rwrite  (const REALMATRIX&amp; x,<br>                           const long w);<br>friend void       rshow   (const REALMATRIX&amp; x,<br>                           const long w);<br><br>// Limits: --------------------------<br><br>friend REALMATRIX limit_lip (REALMATRIX f(long, const REALMATRIX&amp;),<br>                           long lip,<br>                           const REALMATRIX&amp; x);<br><br><br>public:<br>REAL*  values; <br>unsigned int    maxrow,maxcolumn;<br>void adderror (sizetype error);<br>void seterror (sizetype error);<br>void geterror (sizetype&amp; error) const;<br>};<br><br>class SPM_ELEMENT<br>{ public:<br>REAL value;<br>unsigned int rowindex;<br>unsigned int colindex;<br>SPM_ELEMENT* nextcol;<br>SPM_ELEMENT* nextrow; <br>};<br></pre>
        <a href="#iRRAM_:_exact_real_arithmetic_">Back  to top</a><br>
               
<hr width="100%" size="2"><br>
       <br>
     <a name="SPARSEREALMATRIX"></a><b><big>Sparse matrices of real numbers</big></b><br>
                 
<pre>/****************************************************************************/<br>// Definition of class SPARSEREALMATRIX<br>/****************************************************************************/<br><br>class SPARSEREALMATRIX<br>{<br>public:<br>// Constructors: -------------------------------<br><br>SPARSEREALMATRIX(unsigned int rows,unsigned int columns);<br>SPARSEREALMATRIX();<br>SPARSEREALMATRIX(const SPARSEREALMATRIX&amp; y);<br>// Copy Constructor: ---------------------------<br><br>SPARSEREALMATRIX&amp;   operator = (const SPARSEREALMATRIX&amp; y);<br><br>// Destructor: ---------------------------------<br><br>~SPARSEREALMATRIX();<br>void clear();<br>void free();<br><br>// Access to matrix elements: ------------------<br><br>friend void sparse_set(SPARSEREALMATRIX&amp; m,unsigned int i,unsigned int j,const REAL&amp; x);<br>friend void sparse_unset(SPARSEREALMATRIX&amp; m,unsigned int i,unsigned int j);<br>friend SPM_ELEMENT* sparse_get_ptr(SPARSEREALMATRIX&amp; m,unsigned int i,unsigned int j);<br><br>REAL    operator ()           (unsigned int row,<br>                               unsigned int column);<br><br><br>// Standard Arithmetic: ------------------------<br><br>friend SPARSEREALMATRIX  operator + (const SPARSEREALMATRIX&amp; x,<br>                               const SPARSEREALMATRIX&amp; y);<br>friend SPARSEREALMATRIX  operator - (const SPARSEREALMATRIX&amp; x,<br>                               const SPARSEREALMATRIX&amp; y);<br>friend SPARSEREALMATRIX  operator * (const SPARSEREALMATRIX&amp; x,<br>                               const SPARSEREALMATRIX&amp; y);<br>friend SPARSEREALMATRIX  operator / (const SPARSEREALMATRIX&amp; x,<br>                               const SPARSEREALMATRIX&amp; y);<br><br>// Arithmetic with Scalar: ---------------------<br>friend SPARSEREALMATRIX  operator * (const SPARSEREALMATRIX&amp; x,<br>                               const REAL&amp; y);<br>inline friend SPARSEREALMATRIX operator * (const REAL&amp; y,<br>                               const SPARSEREALMATRIX&amp; x)<br>       {return x*y;};<br><br>friend SPARSEREALMATRIX  operator / (const SPARSEREALMATRIX&amp; x,<br>                               const REAL&amp; y);<br><br>// Information on Dimensions: ------------------<br><br>friend inline unsigned int rows (const SPARSEREALMATRIX&amp; x)<br>                {return x.maxrow;};<br>friend inline unsigned int columns (const SPARSEREALMATRIX&amp; x)<br>                {return x.maxcolumn;};<br><br>friend int bound (const SPARSEREALMATRIX&amp; x, <br>                  const long k);<br><br>// Linear Algebra: --------------------------<br><br>friend SPARSEREALMATRIX sparse_eye     (unsigned int rows);<br>friend SPARSEREALMATRIX sparse_zeroes  (unsigned int rows,<br>                           unsigned int columns);<br>friend SPARSEREALMATRIX sparse_ones    (unsigned int rows,<br>                           unsigned int columns);<br>friend REAL       maxnorm (const SPARSEREALMATRIX&amp; x);<br>friend REAL       rowsumnorm (const SPARSEREALMATRIX&amp; x);<br>friend REAL       colsumnorm (const SPARSEREALMATRIX&amp; x);<br><br>friend SPARSEREALMATRIX solve (<br>       SPARSEREALMATRIX&amp; lside,<br>       SPARSEREALMATRIX&amp; rside,<br>       int use_pivot);<br><br><br>// IO-routines: --------------------------<br><br>friend void       rwrite  (const SPARSEREALMATRIX&amp; x,<br>                           const long p,<br>                           const long w);<br>friend void       rwrite  (const SPARSEREALMATRIX&amp; x,<br>                           const long w);<br>friend void       rshow   (const SPARSEREALMATRIX&amp; x,<br>                           const long w);<br><br>// Limits: --------------------------<br><br>friend SPARSEREALMATRIX limit_lip (SPARSEREALMATRIX f(long, const SPARSEREALMATRIX&amp;),<br>                           long lip,<br>                           const SPARSEREALMATRIX&amp; x);<br><br>//friend SPARSEREALMATRIX limit_mv (SPARSEREALMATRIX f(long prec,<br>//                                         long* choice,<br>//                                         const SPARSEREALMATRIX&amp;),<br>//                           const SPARSEREALMATRIX&amp; x);<br><br>//private:<br>SPM_ELEMENT**  rowvector; <br>SPM_ELEMENT**  colvector; <br>SPM_ELEMENT* hotspot;<br>unsigned int    maxrow,maxcolumn,filled;<br>void adderror (sizetype error);<br>void seterror (sizetype error);<br>void geterror (sizetype&amp; error) const;<br>};<br></pre>
        <a href="#iRRAM_:_exact_real_arithmetic_">Back  to top</a><br>
               
<hr width="100%" size="2"><br>
       <br>
     <a name="INTERVAL"></a><b><big>Intervals of real numbers</big></b><br>
                 
<pre>/****************************************************************************/<br>// Definition of class INTERVAL<br>/****************************************************************************/<br>class INTERVAL <br>{<br>public:<br><br>// Constructors: -------------------------------<br><br>INTERVAL();<br><br>INTERVAL(const REAL&amp; real);<br>INTERVAL(const REAL&amp; reala, const REAL&amp; realb);<br><br>// Standard Arithmetic: ------------------------<br><br>friend INTERVAL  operator +  (const INTERVAL&amp; x,<br>                             const INTERVAL&amp; y);<br>friend INTERVAL  operator -  (const INTERVAL&amp; x,<br>                             const INTERVAL&amp; y);<br>friend INTERVAL  operator *  (const INTERVAL&amp; x,<br>                             const INTERVAL&amp; y);<br>friend INTERVAL  operator /  (const INTERVAL&amp; x,<br>                             const INTERVAL&amp; y);<br><br>friend REAL width(const INTERVAL&amp; x);<br>friend REAL lower(const INTERVAL&amp; x);<br>friend REAL upper(const INTERVAL&amp; x);<br><br>private :<br>REAL low;<br>REAL upp;<br><br>};<br></pre>
        <a href="#iRRAM_:_exact_real_arithmetic_">Back  to top</a><br>
               
<hr width="100%" size="2"><br>
       <br>
     <a name="COMPLEX"></a><b><big>Complex numbers</big></b><br>
                 
<pre>/****************************************************************************/<br>// Definition of class COMPLEX <br>/****************************************************************************/<br><br>class COMPLEX :public REALMATRIX<br>{<br>public:<br><br>// Constructors: -------------------------------<br><br>COMPLEX();<br>COMPLEX(const REAL&amp; real_part);<br>COMPLEX(const REALMATRIX&amp;);<br>COMPLEX(const REAL&amp; real_part, const REAL&amp; imag_part);<br><br>// Copy Constructor: ---------------------------<br>// (already defined in base class REALMATRIX)<br><br>// Standard Arithmetic: ------------------------<br><br>friend COMPLEX  operator +  (const COMPLEX&amp; x,<br>                             const COMPLEX&amp; y);<br>friend COMPLEX  operator -  (const COMPLEX&amp; x,<br>                             const COMPLEX&amp; y);<br>friend COMPLEX  operator -  (const COMPLEX&amp; x);<br>friend COMPLEX  operator *  (const COMPLEX&amp; x,<br>                             const COMPLEX&amp; y);<br>friend COMPLEX  operator /  (const COMPLEX&amp; x,<br>                             const COMPLEX&amp; y);<br><br>friend REAL real(const COMPLEX&amp; z);<br>friend REAL imag(const COMPLEX&amp; z);<br>friend REAL abs (const COMPLEX&amp; z);<br><br>COMPLEX log(const COMPLEX&amp; z);<br>COMPLEX exp(const COMPLEX&amp; z);<br><br>/****************************/<br>/* trigonometric functions  */<br>/****************************/<br><br>COMPLEX sin(const COMPLEX&amp; z);<br>COMPLEX cos(const COMPLEX&amp; z);<br>COMPLEX tan(const COMPLEX&amp; z);<br>COMPLEX cotan(const COMPLEX&amp; z);<br>COMPLEX sec(const COMPLEX&amp; z);<br>COMPLEX cosec(const COMPLEX&amp; z);<br><br>COMPLEX sinh(const COMPLEX&amp; z);<br>COMPLEX cosh(const COMPLEX&amp; z);<br>COMPLEX tanh(const COMPLEX&amp; z);<br>COMPLEX coth(const COMPLEX&amp; z);<br>COMPLEX sech(const COMPLEX&amp; z);<br>COMPLEX cosech(const COMPLEX&amp; z);<br><br>COMPLEX asin(const COMPLEX&amp; z);<br>COMPLEX acos(const COMPLEX&amp; z);<br>COMPLEX atan(const COMPLEX&amp; z);<br>COMPLEX acotan(const COMPLEX&amp; z);<br>COMPLEX asec(const COMPLEX&amp; z);<br>COMPLEX acosec(const COMPLEX&amp; z);<br><br>COMPLEX asinh(const COMPLEX&amp; z);<br>COMPLEX acosh(const COMPLEX&amp; z);<br>COMPLEX atanh(const COMPLEX&amp; z);<br>COMPLEX acoth(const COMPLEX&amp; z);<br>COMPLEX asech(const COMPLEX&amp; z);<br>COMPLEX acosech(const COMPLEX&amp; z);<br><br>};<br></pre>
        <a href="#iRRAM_:_exact_real_arithmetic_">Back  to top</a><br>
               
<hr width="100%" size="2"><br>
       <br>
     <a name="functions"></a><b><big>Functions</big></b><br>
                 
<pre>/****************************************************************************/<br>// arithmetic functions<br>/****************************************************************************/<br>REAL power(const REAL&amp; x, const REAL&amp; y);<br>REAL power(const REAL&amp; x, long n);<br>REAL power(const REAL&amp; x, int n);<br>REAL modulo  (const REAL&amp; x, const REAL&amp; y);<br>REAL maximum (const REAL&amp; x, const REAL&amp; y);<br>REAL minimum (const REAL&amp; x, const REAL&amp; y);<br><br>/****************************************************************************/<br>// roots<br>/****************************************************************************/<br>REAL sqrt    (const REAL&amp; x);<br>REAL root    (const REAL&amp; x,long n);<br><br>/****************************************************************************/<br>// trigonometric functions<br>/****************************************************************************/<br>REAL sin     (const REAL&amp; x);<br>REAL cos     (const REAL&amp; x);<br>REAL tan     (const REAL&amp; x);<br>REAL cotan   (const REAL&amp; x);<br>REAL sec     (const REAL&amp; x);<br>REAL cosec   (const REAL&amp; x);<br><br>/****************************************************************************/<br>// inverse trigonometric functions<br>/****************************************************************************/<br>REAL atan    (const REAL&amp; x);<br>REAL asin    (const REAL&amp; x);<br>REAL acos    (const REAL&amp; x);<br>REAL acotan  (const REAL&amp; x);<br>REAL asec    (const REAL&amp; x);<br>REAL acosec  (const REAL&amp; x);<br><br>/****************************************************************************/<br>//hyperbolic functions<br>/****************************************************************************/<br>REAL sinh    (const REAL&amp; x);<br>REAL cosh    (const REAL&amp; x);<br>REAL tanh    (const REAL&amp; x);<br>REAL coth    (const REAL&amp; x);<br>REAL sech    (const REAL&amp; x);<br>REAL cosech  (const REAL&amp; x);<br><br>/****************************************************************************/<br>// inverse hyperbolic functions <br>/****************************************************************************/<br>REAL asinh   (const REAL&amp; x);<br>REAL acosh   (const REAL&amp; x);<br>REAL atanh   (const REAL&amp; x);<br>REAL acoth   (const REAL&amp; x);<br>REAL asech   (const REAL&amp; x);<br>REAL acosech (const REAL&amp; x);<br><br>/****************************************************************************/<br>// exponentiation + logarithm<br>/****************************************************************************/<br>REAL exp     (const REAL&amp; x);<br>REAL log     (const REAL&amp; x);<br><br>/****************************************************************************/<br>// special constants values                                                 <br>/****************************************************************************/<br>REAL pi      ();   // = 3.141592653...<br>REAL euler   ();   // = 2.718281828...<br>REAL ln2     ();   // = 0.693147180...<br><br>/****************************************************************************/<br>//  matrix functions<br>/****************************************************************************/<br>REALMATRIX exp    (const REALMATRIX&amp; x);<br><br>REALMATRIX steady_state (const REALMATRIX&amp; x);<br><br>REALMATRIX steady_state (const SPARSEREALMATRIX&amp; x);<br>REALMATRIX equilib (const SPARSEREALMATRIX&amp; x);<br>void equilib_del (SPARSEREALMATRIX&amp; x,REALMATRIX&amp; z);<br><br><br>/****************************************************************************/<br>// complex functions<br>/****************************************************************************/<br><br>// defined for any complex number:<br>COMPLEX  sqrt(const COMPLEX&amp; z);<br><br>// only defined for |z| &gt; 0 (faster if |z| &gt;&gt; 0 ) :<br>COMPLEX csqrt(const COMPLEX&amp; z);<br></pre>
        <a href="#iRRAM_:_exact_real_arithmetic_">Back  to top</a><br>
                
<hr width="100%" size="2"><br>
       <br>
     <a name="limits"></a><b><big>Limit operators</big></b><br>
                 
<pre>/****************************************************************************/<br>// templates for limit operators<br>/****************************************************************************/<br><br>template <class
 argument="" class="" result=""> <br>RESULT limit_mv (RESULT f(long prec,<br>                                         long* choice,<br>                                         const ARGUMENT&amp;),<br>                           const ARGUMENT&amp; x);<br><br>template <class
 argument="" class="" result=""> <br>RESULT limit (RESULT f(long prec,const ARGUMENT&amp;),<br>                           const ARGUMENT&amp; x);<br><br><br>template <class
 argument="" class="" result=""> <br>RESULT limit (RESULT f(long prec,const ARGUMENT&amp;, long),<br>                           const ARGUMENT&amp; x, long param);<br><br><br><br></class></class></class></pre>
        <a href="#iRRAM_:_exact_real_arithmetic_">Back  to top</a><br>
                
<hr width="100%" size="2"><br>
       <br>
     <a name="INTEGER"></a><b><big>Integer numbers</big></b><br>
                 
<pre>//****************************************************************************************/<br>/* Definition of class INTEGER                                                           */<br>//****************************************************************************************/<br><br>class INTEGER <br>{<br>	public:<br><br>	friend class REAL;<br>	friend class DYADIC;<br>	friend class RATIONAL;<br>	friend class RAND;<br><br>	/****** Constructors ******/<br><br>	INTEGER();<br>	INTEGER(int i);<br>	INTEGER(long i);<br>	INTEGER(char* s);<br>	INTEGER(const DYADIC&amp; y); <br>	INTEGER(const REAL&amp; y);  <br>	INTEGER(const REAL&amp; y, long p); <br>	INTEGER(double d);<br><br><br><br>	/****** Copy constructor ******/<br><br>	INTEGER&amp; operator = (const INTEGER&amp; y);<br>	INTEGER&amp; operator = (int y);<br>	INTEGER&amp; operator = (long int y);<br><br>	/****** Destructor ******/<br>	<br>	~INTEGER();<br><br>	/****** Standard arithmetic ******/<br><br>	friend INTEGER 	operator + 	(const INTEGER&amp; x, const INTEGER&amp; y);<br>	friend INTEGER 	operator + 	(const INTEGER&amp; x, long int n      );<br>	friend INTEGER 	operator + 	(long int n	     , const INTEGER&amp; y);<br>	friend INTEGER&amp;	operator +=	(      INTEGER&amp; x, const INTEGER&amp; y);<br>	friend INTEGER&amp;	operator +=	(      INTEGER&amp; x, long int n	     );<br>	friend INTEGER 	operator - 	(const INTEGER&amp; x, const INTEGER&amp; y);<br>	friend INTEGER 	operator - 	(const INTEGER&amp; x, long int n      );<br>	friend INTEGER 	operator - 	(long int n      , const INTEGER&amp; y);<br>	friend INTEGER 	operator - 	(const INTEGER&amp; x);<br>	friend INTEGER 	operator * 	(const INTEGER&amp; x, const INTEGER&amp; y);<br>	friend INTEGER	operator *	(const INTEGER&amp; x, long int n);<br>	friend INTEGER	operator *	(long int n      , const INTEGER&amp; x);<br>	friend INTEGER&amp;	operator *=	(	 INTEGER&amp; x, const INTEGER&amp; y);<br>	friend INTEGER&amp;	operator *=	(	 INTEGER&amp; x, long int n);<br>	friend INTEGER 	operator / 	(const INTEGER&amp; x, const INTEGER&amp; y);<br>	friend INTEGER 	operator / 	(const INTEGER&amp; x, long int n);<br>	friend INTEGER 	operator / 	(long int n      ,const INTEGER&amp; x);<br>	friend INTEGER 	operator ^ 	(const INTEGER&amp; x, const INTEGER&amp; y);<br>	friend INTEGER  operator ^  (const INTEGER&amp; x, unsigned long int n);<br>	friend INTEGER 	operator &lt;&lt; (const INTEGER&amp; x, long int n);<br>	friend INTEGER 	operator &gt;&gt; (const INTEGER&amp; x, long int n);<br>	friend INTEGER	operator %  (const INTEGER&amp; x, const INTEGER&amp; y);<br><br>	friend INTEGER 	sqrt		(const INTEGER&amp; x);<br>	friend INTEGER	square	(const INTEGER&amp; x);<br>	friend INTEGER	scale		(const INTEGER&amp; x, long int k);<br>	friend INTEGER 	factorial	(long int x);<br>	friend INTEGER	root    	(const INTEGER&amp; x,unsigned long n);<br>	friend INTEGER	abs		(const INTEGER&amp; x);<br>	friend INTEGER	log2		(const INTEGER&amp; x);<br><br><br>	/****** Comparisons ******/<br><br>	friend bool 	operator &lt;  (const INTEGER&amp; x, const INTEGER&amp; y);<br>	friend bool 	operator &lt;= (const INTEGER&amp; x, const INTEGER&amp; y);<br>	friend bool 	operator &gt;  (const INTEGER&amp; x, const INTEGER&amp; y);<br>	friend bool 	operator &gt;= (const INTEGER&amp; x, const INTEGER&amp; y);<br>	friend bool 	operator == (const INTEGER&amp; x, const INTEGER&amp; y);<br>	friend bool 	operator != (const INTEGER&amp; x, const INTEGER&amp; y);<br>	<br>	friend INTEGER 	maximum  	(const INTEGER&amp; x, const INTEGER&amp; y);<br>	friend INTEGER 	minimum 	(const INTEGER&amp; x, const INTEGER&amp; y);<br>	<br>	friend bool		positive	(const INTEGER&amp; x);<br><br>	/****** Output ******/<br><br>	friend void 	rwrite	(const INTEGER&amp; x, const long w);<br>	friend char*    swrite  (const INTEGER&amp; x, const long w);<br>	friend char*    swrite  (const INTEGER&amp; x);<br>	friend void     rprintf (const INTEGER&amp; x);<br>	friend INTEGER 	strtoINTEGER(char* s, char** endptr);<br>	friend INTEGER 	atoINTEGER	(char* s);<br>	friend INTEGER 	INTEGER_random(long max, RAND rand);<br><br><br>	/****** Implementational issues ******/<br><br>	int size(); //****** will be private<br><br>	/****** Private ******/<br>private:<br><br>	MP_int_type value;<br>	INTEGER(MP_int_type y);<br><br>};<br></pre>
        <a href="#iRRAM_:_exact_real_arithmetic_">Back  to top</a><br>
                
<hr width="100%" size="2"><br>
       <br>
     <a name="RATIONAL"></a><b><big>Rational numbers</big></b><br>
                 
<pre>/****************************************************************************************/<br>/* Definition of class RATIONAL                                                         */<br>/****************************************************************************************/<br><br>class RATIONAL<br>{<br>	public:<br><br>	friend class INTEGER;<br>	friend class REAL;<br><br>	/****** Constructors ******/<br><br>	inline RATIONAL(MP_rat_type y);<br>	RATIONAL();<br>	RATIONAL(int i);<br>	RATIONAL(long i);<br>	RATIONAL(long i, long j);<br>	RATIONAL(int i, int j);<br>	RATIONAL(char* s);<br>	RATIONAL(const DYADIC&amp; y); <br>	RATIONAL(const REAL&amp; y);  <br>	RATIONAL(const INTEGER&amp; y);<br>	RATIONAL(const INTEGER&amp; x, const INTEGER&amp; y);<br>	RATIONAL(double d);<br>	RATIONAL(const REAL&amp; x, const INTEGER&amp; den, long prec);<br><br>	/****** Copy constructor ******/<br><br>	RATIONAL&amp; operator = (const RATIONAL&amp; y);<br>	RATIONAL&amp; operator = (int y);<br><br>	/****** Destructor ******/<br>	<br>	~RATIONAL();<br><br>	/****** Standard arithmetic ******/<br><br>	friend RATIONAL 	operator + 	(const RATIONAL&amp; x, const RATIONAL&amp; y);<br>	friend RATIONAL 	operator + 	(const RATIONAL&amp; x, long int n       );<br>	friend RATIONAL 	operator + 	(long int n       , const RATIONAL&amp; y);<br>	friend RATIONAL&amp;	operator +=	(      RATIONAL&amp; x, const RATIONAL&amp; y);<br>	friend RATIONAL 	operator - 	(const RATIONAL&amp; x, const RATIONAL&amp; y);<br>	friend RATIONAL 	operator - 	(const RATIONAL&amp; x, long int n       );<br>	friend RATIONAL 	operator - 	(long int n       , const RATIONAL&amp; y);<br>	friend RATIONAL 	operator - 	(const RATIONAL&amp; x);<br>	friend RATIONAL 	operator * 	(const RATIONAL&amp; x, const RATIONAL&amp; y);<br>	friend RATIONAL		operator *	(const RATIONAL&amp; x, long int n);<br>	friend RATIONAL		operator *	(long int n       , const RATIONAL&amp; x);<br>	friend RATIONAL&amp;	operator *=	(	 RATIONAL&amp; x, const RATIONAL&amp; y);<br>	friend RATIONAL&amp;	operator *=	(	 RATIONAL&amp; x, long int n);<br>	friend RATIONAL&amp;	operator *=	(	 RATIONAL&amp; x, int n);<br>	friend RATIONAL 	operator / 	(const RATIONAL&amp; x, const RATIONAL&amp; y);<br>	friend RATIONAL 	operator / 	(const RATIONAL&amp; x, long int n);<br>	friend RATIONAL 	operator / 	(long int n       , const RATIONAL&amp; x);<br>	friend RATIONAL 	operator ^ 	(const RATIONAL&amp; x, const RATIONAL&amp; y);<br>	friend RATIONAL		operator ^  (const RATIONAL&amp; x, long unsigned int n);<br>	friend RATIONAL 	operator &lt;&lt; (const RATIONAL&amp; x, long int n);<br>	friend RATIONAL 	operator &gt;&gt; (const RATIONAL&amp; x, long int n);<br>	friend RATIONAL		operator %  (const RATIONAL&amp; x, const RATIONAL&amp; y);<br><br>	friend RATIONAL		square		(const RATIONAL&amp; x);<br>	friend RATIONAL		scale		(const RATIONAL&amp; x, long int k);<br><br>	friend RATIONAL 	sqrt 		(const RATIONAL&amp; x);<br>	friend RATIONAL		root    	(const RATIONAL&amp; x,long n);<br>	friend RATIONAL		abs		(const RATIONAL&amp; x);<br>	friend RATIONAL		log2		(const RATIONAL&amp; x);<br>	friend RATIONAL		sqrt_int	(const RATIONAL&amp; x);<br><br>	/****** Comparisons ******/<br><br>	friend bool 	operator &lt;      (const RATIONAL&amp; x, const RATIONAL&amp; y);<br>	friend bool 	operator &lt;=     (const RATIONAL&amp; x, const RATIONAL&amp; y);<br>	friend bool 	operator &gt;      (const RATIONAL&amp; x, const RATIONAL&amp; y);<br>	friend bool 	operator &gt;=     (const RATIONAL&amp; x, const RATIONAL&amp; y);<br>	friend bool 	operator ==     (const RATIONAL&amp; x, const RATIONAL&amp; y);<br>	friend bool 	operator !=     (const RATIONAL&amp; x, const RATIONAL&amp; y);<br><br>	friend RATIONAL 	maximum  	(const RATIONAL&amp; x, const RATIONAL&amp; y);<br>	friend RATIONAL 	minimum 	(const RATIONAL&amp; x, const RATIONAL&amp; y);<br>	<br>	friend bool		positive	(const RATIONAL&amp; x, const long k);<br><br>	/****** Output ******/<br><br>	friend void 	rwrite		(const RATIONAL&amp; x, const long w);<br>	friend char*    swrite          (const RATIONAL&amp; x, const long w);<br>	friend char*    swrite          (const RATIONAL&amp; x);<br>	friend void 	rprintf     	(const RATIONAL&amp; x);<br>	friend RATIONAL 	strtoRATIONAL    	(char* s, char** endptr);<br>	friend RATIONAL 	atoRATIONAL		(char* s);<br><br><br>	/****** Private ******/<br>private:<br><br>	MP_rat_type value;<br>	RATIONAL(MP_int_type y);<br>	friend RATIONAL cos_prec_infinite(const RATIONAL&amp; x, long prec);<br>	friend RATIONAL cos_prec_infinite2(const RATIONAL&amp; x, long prec);<br>	int RATIONAL::size();<br>};<br></pre>
         <a href="#iRRAM_:_exact_real_arithmetic_">Back  to top</a><br>
   <br>
                 
</body>
</html>
